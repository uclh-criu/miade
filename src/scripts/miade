#!/usr/bin/env python
import os
import json
import datetime
import logging

import typer
import yaml
import pandas as pd

from pathlib import Path
from shutil import rmtree
from typing import Optional, List
from pydantic import BaseModel

from medcat.cat import CAT
from medcat.meta_cat import MetaCAT
from medcat.config_meta_cat import ConfigMetaCAT
from medcat.tokenizers.meta_cat_tokenizers import TokenizerWrapperBPE

from miade.model_builders import CDBBuilder

log = logging.getLogger("miade")

app = typer.Typer()


class CLI_Config(BaseModel):
    snomed_data_path: Optional[Path] = None
    fdb_data_path: Optional[Path] = None
    elg_data_path: Optional[Path] = None
    snomed_subset_path: Optional[Path] = None
    snomed_exclusions_path: Optional[Path] = None
    medcat_config_file: Optional[Path] = None
    training_data_path: Path
    output_dir: Path

    @classmethod
    def from_yaml_file(cls, config_filepath: Path):
        with config_filepath.open("r") as stream:
            config_dict = yaml.safe_load(stream)
            return cls(**config_dict)


@app.command()
def build_model_pack(
        cdb_data_path: Path,
        vocab_path: Path,
        description: Optional[str] = None,
        ontology: Optional[str] = None,
        tag: Optional[str] = None,
        output: Optional[Path] = typer.Argument(Path.cwd()),
        temp: Optional[Path] = typer.Argument(Path.cwd() / Path(".temp"))
):
    # builds from cdb already in format and vocab from another medcat model
    log.info(f"Building CDB from {str(cdb_data_path)}...")
    cdb_builder = CDBBuilder(
        temp_dir=temp,
        custom_data_paths=[cdb_data_path]
    )
    cdb_builder.preprocess()
    cdb = cdb_builder.create_cdb()

    log.info(f"Creating model pack with vocab from {str(vocab_path)}...")
    vocab_cat = CAT.load_model_pack(str(vocab_path))
    cat = CAT(cdb=cdb, config=cdb.config, vocab=vocab_cat.vocab)

    if description is None:
        log.info("Automatically populating description field of model card...")
        split_tag = ''
        if tag is not None:
            split_tag = ' '.join(tag.split('_')) + ' '
        description = f"MiADE {split_tag}untrained model built using cdb from " \
                      f"{cdb_data_path.stem}{cdb_data_path.suffix} and vocab " \
                      f"from model {vocab_path.stem}"

    cat.config.version["location"] = str(output)
    cat.config.version["description"] = description
    cat.config.version["ontology"] = ontology

    current_date = datetime.datetime.now().strftime("%b_%Y")
    name = f"miade_{tag}_blank_modelpack_{current_date}" if tag is not None else f"miade_blank_modelpack_{current_date}"

    cat.create_model_pack(str(output), name)


@app.command()
def train(
        model: Path, data: Path,
        checkpoint: int = 5000,
        description: Optional[str] = None,
        tag: Optional[str] = None,
        train_partial: Optional[int] = None,
        output: Optional[Path] = typer.Argument(Path.cwd())
):
    if data.suffix == ".csv":
        log.info(f"Loading text column of csv file {data}...")
        df = pd.read_csv(data)
        training_data = df.text.to_list()
    else:
        log.info(f"Loading text file {data}...")
        with data.open('r') as d:
            training_data = [line.strip() for line in d]
    log.info(f"Training data length: {len(training_data)}")
    log.info(f"Data check: {training_data[0][:100]}")

    if train_partial:
        log.info(f"Partial training first {train_partial} documents")
        training_data = training_data[:train_partial]

    cat = CAT.load_model_pack(str(model))

    if checkpoint:
        log.info(f"Checkpoint steps configured to {checkpoint}")
        cat.config.general["checkpoint"]["steps"] = checkpoint
        cat.config.general["checkpoint"]["output_dir"] = os.path.join(Path.cwd(), "checkpoints")

    cat.train(training_data)

    if description is None:
        log.info("Automatically populating description field of model card...")
        split_tag = ''
        if tag is not None:
            split_tag = ' '.join(tag.split('_')) + ' '
        description = f"MiADE {split_tag}unsupervised trained model trained on text dataset {data.stem}{data.suffix}"

    cat.config.version["description"] = description
    cat.config.version["location"] = str(output)

    current_date = datetime.datetime.now().strftime("%b_%Y")
    name = f"miade_{tag}_unsupervised_trained_modelpack_{current_date}" if tag is not None \
        else f"miade_unsupervised_trained_modelpack_{current_date}"

    cat.create_model_pack(str(output), name)


@app.command()
def train_supervised(
        model: Path, annotations_path: Path,
        nepochs: int = 1,
        use_filters: bool = False,
        print_stats: bool = True,
        train_from_false_positives: bool = True,
        is_resumed: bool = False,
        description: Optional[str] = None,
        tag: Optional[str] = None,
        output: Optional[Path] = typer.Argument(Path.cwd())
):
    cat = CAT.load_model_pack(str(model))

    log.info(f"Starting {nepochs} epoch(s) supervised training with {annotations_path}")
    fp, fn, tp, p, r, f1, cui_counts, examples = cat.train_supervised(data_path=str(annotations_path),
                                                                      nepochs=nepochs,
                                                                      use_filters=use_filters,
                                                                      print_stats=print_stats,
                                                                      train_from_false_positives=train_from_false_positives,
                                                                      is_resumed=is_resumed)

    # populate the description field in versioning
    if description is None:
        log.info("Automatically populating description field of model card...")
        split_tag = ''
        if tag is not None:
            split_tag = ' '.join(tag.split('_')) + ' '
        description = f"MiADE {split_tag}supervised trained model with annotations file {annotations_path.stem}"

    cat.config.version["description"] = description
    cat.config.version["location"] = str(output)

    current_date = datetime.datetime.now().strftime("%b_%Y")
    name = f"miade_{tag}_supervised_trained_modelpack_{current_date}" if tag is not None \
        else f"miade_supervised_trained_modelpack_{current_date}"

    cat.create_model_pack(str(output), name)
    # dump the training stats into a json file for reference(they are very long)
    model_id = cat.config.version["id"]
    training_stats = {"fp": fp,
                      "fn": fn,
                      "tp": tp,
                      "p": p,
                      "r": r,
                      "f1": f1,
                      "cui_counts": cui_counts}
    # version without training text
    with open(str(output) + f"problems_model_supervised_training_stats_without_text_{model_id}.json", 'w') as f:
        json.dump(training_stats, f)

    training_stats["examples"] = examples
    # version with training text
    with open(str(output) + f"problems_model_supervised_training_stats_with_text_{model_id}.json", 'w') as f:
        json.dump(training_stats, f)

    log.info(f"Saved training stats at {str(output)}")


@app.command()
def train_metacat(
        model_path: Path, annotation_path: Path,
        cntx_left: int = 20,
        cntx_right: int = 15,
        description: str = None
):
    mc = MetaCAT.load(str(model_path))

    if description is None:
        description = f"MiADE meta-annotations model {model_path.stem} trained on {annotation_path.stem}"

    mc.config.general["description"] = description
    mc.config.general["category_name"] = model_path.stem.split("_")[-1]  # meta folder name should be e.g. meta_presence
    mc.config.general["cntx_left"] = cntx_left
    mc.config.general["cntx_right"] = cntx_right

    log.info(
        f"Starting metacat training for {mc.config.general['category_name']} with annotation file {annotation_path}")
    report = mc.train(json_path=str(annotation_path), save_dir_path=str(model_path))
    training_stats = {mc.config.general["category_name"]: report}

    with open(str(model_path) + "training_report.json", 'w') as f:
        json.dump(training_stats, f)

    log.info(f"Saved training report at {str(model_path)}")


@app.command()
def add_metacat_models(
        model: Path, meta_cats_path: List[Path],
        description: str = None,
        output: Optional[Path] = typer.Argument(Path.cwd())
):
    cat = CAT.load_model_pack(str(model))

    meta_cats = []
    categories = []
    stats = {}
    for metacat in meta_cats_path:
        mc = MetaCAT.load(str(metacat))
        meta_cats.append(mc)
        categories.append(mc.config.general["category_name"])
        log.info(f"Loaded meta model {categories[-1]}")
        # get training stats if there are any
        report_path = str(metacat) + "training_report.json"
        if os.path.exists(report_path):
            log.info(f"Loading training_report.json from {str(metacat)}...")
            with open(str(metacat) + "training_report.json") as f:
                report = json.load(f)
            stats[categories[-1]] = report

    cat_w_meta = CAT(cdb=cat.cdb, vocab=cat.vocab, config=cat.config, meta_cats=meta_cats)

    if description is None:
        description = cat.config.version["description"] + " Packaged with meta models " + ", ".join(categories)
    cat.config.version["description"] = description
    for category in categories:
        cat.config.version["performance"]["meta"][category] = stats[category]

    save_name = model.stem.rsplit("_", 1)[0] + "_w_meta"
    cat_w_meta.create_model_pack(str(output), save_name)


@app.command()
def rename_model_pack(
        model: Path, new_name: str,
        remove_old: bool = True,
        description: Optional[str] = None,
        location: Optional[str] = None,
        ontology: Optional[str] = None,
        performance: Optional[str] = None,
        output: Optional[Path] = typer.Argument(Path.cwd())
):
    cat = CAT.load_model_pack(str(model))
    if description is not None:
        log.info("Adding description to model card...")
        cat.config.version["description"] = description
    if location is not None:
        log.info("Adding location to model card...")
        cat.config.version["location"] = location
    if ontology is not None:
        log.info("Adding ontology to model card...")
        cat.config.version["ontology"] = ontology
    if performance is not None:
        log.info("Adding performance to model card...")
        cat.config.version["performance"] = performance

    cat.create_model_pack(str(output), new_name)

    # remove old model
    if remove_old:
        log.info(f"Removing old model {str(model)}")
        os.remove(str(model) + ".zip")
        rmtree(model)


if __name__ == "__main__":
    app()
